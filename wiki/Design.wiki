#summary Basic design information
#labels Phase-Design

= Program Flow =

  # Parse command line arguments
    * -c Config file
    * -t Tag
    * -h Usage
  # Check for a argument
    * Fail with usage if nothing was specified
  # Read in config (default: /etc/cronwatch.conf)
    * If no config file is specified, run with defaults
    * If -c is specified, exit with error if can't read the config file
  # Run program
    * If can't run, flag error
    * Capture stdout, stderr
    * Null route stdin
    * stderr can be routed to stdout
  # Process stdout
    * Apply rules to stdout
        * Required regex(es) must be in the input
        * Blacklist regex(es) flag error if found
        * Whitelist regex(es) flag error if a line doesn't match
    * Stderr is handled differently
      * If stderr is configured as error, flag error
      * If stderr is routed to stdout, ignore since it will be handled as stdout
      * If stderr is set to ignore, then it will be ignored
    * Exit codes
        * Required exit code must be set
        * 
  # Store logs
    * Note: we may need to buffer this somehow, because if we wait until the program exits and we get killed, then we're going to lose the logs
  # Report errors
  # Clean up old logs


= Basic Usage =
* * * * * root cronwatch -c job.conf -t tag /usr/local/bin/myjob -c 1 parm 1


= Design Decisions =
These are various design decisions encountered in the development and the reasoning behind the route that we took.

==stdout and stderr Interpolation==
Consider the following shell snippet:

{{{
echo stdout; sleep 1; echo stderr 1>&2; sleep 1; echo stdout2
}}}

If you run this line from the shell, here the output you will see (with one second pauses between the lines):

{{{
stdout
stderr
stdout2
}}}

Cronwatch could capture the output from this snippet in three ways:

  # Separate stdout and stderr and handle the two separately
  # Somehow poll stdout and stderr to try to get a chronologically correct output
  # Combine stdout and stderr and handle them together



This decision was a hard one. Ideally cronwatch would handle stdout and stderr differently, but would offer a chronologically correct interpolation